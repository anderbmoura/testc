# GitHub Copilot Instructions - DSC Library

## Project Context

React Native UI library built with **Tamagui** framework. Technologies:

- **React Native + TypeScript**: Strict typing required
- **Tamagui**: UI framework with design tokens and styled components
- **iconoir-react-native**: Standard icon library
- **Storybook**: Primary documentation platform

## Component Architecture

### File Structure

```
components/
  ComponentName/
    index.ts                    # Exports
    ComponentName.tsx           # Main component
    ComponentName.model.ts      # Types and interfaces
    ComponentName.stories.tsx   # Storybook stories
    components/                 # Sub-components (if modular)
      StyledComponents.ts       # Styled components
    hooks/                      # Custom hooks (if needed)
      useInteractionState.ts    # Interaction states
```

### Styled Components Pattern

```typescript
const StyledComponent = styled(View, {
  name: 'StyledComponent', // Required for debugging
  backgroundColor: '$color1',
  padding: '$medium',
  borderRadius: '$small',

  // Interactive states
  hoverStyle: {
    backgroundColor: '$color2',
  },
  pressStyle: {
    backgroundColor: '$color3',
  },
  focusStyle: {
    borderColor: '$color9',
    borderWidth: 2,
  },

  variants: {
    theme: {
      highlight: { borderColor: '$color9' },
      danger: { borderColor: '$red9' },
      success: { borderColor: '$green9' },
    },
  } as const,
});
```

## Design Tokens

### Colors (Theme-based)

Use `$color1` (lightest) to `$color12` (darkest) for adaptive colors that change with theme:

```typescript
// ✅ Theme-adaptive colors
backgroundColor: '$color1',    // Changes with theme
borderColor: '$color9',       // Changes with theme
```

Use semantic colors for fixed colors that don't change with theme:

```typescript
// ✅ Semantic colors (always the same)
backgroundColor: '$neutralBg1',  // Always neutral
color: '$successBg',            // Always green
```

### Spacing

- **Micro**: `$nano` (1px), `$quark` (2px), `$tiny` (4px)
- **Small**: `$small` (8px), `$medium` (16px)
- **Large**: `$large` (24px), `$xl` (32px)

### Typography

Always use typography components, never direct text properties:

```typescript
// ✅ Correct
<TitleLarge>Main Title</TitleLarge>
<BodyStandard>Body text</BodyStandard>
<LabelSmall color="$neutral9">Small label</LabelSmall>

// ❌ Avoid
<Text style={{ fontSize: 18, fontWeight: 'bold' }}>Title</Text>
```

## Layout Patterns

### Responsive Layout

Use `YStack` for vertical, `XStack` for horizontal layouts:

```typescript
// ✅ Flexible layout
<YStack space="$medium" padding="$small" $sm={{ padding: '$large' }}>
  <XStack justifyContent="space-between" alignItems="center">
    <TitleMedium flex={1}>Title</TitleMedium>
    <Button size="small">Action</Button>
  </XStack>
</YStack>

// ❌ Fixed sizes
<View style={{ width: 300, height: 200 }}>
  <Text>Content</Text>
</View>
```

## Icons

### iconoir-react-native Integration

Always use `useTransformIcon` hook for consistent sizing and theming:

```typescript
import { useTransformIcon } from '../utils/useTransformIcon';
import { ArrowRight, CreditCard } from 'iconoir-react-native';

// Standard sizes: 16px (buttons), 24px (content), 32px (large)
const smallIcon = useTransformIcon(ArrowRight, {
  size: 16,
  color: '$color9',
});

const largeIcon = useTransformIcon(CreditCard, {
  size: 24,
  color: '$neutral9',
});
```

## Theme Implementation

### When to use theme-adaptive vs semantic colors:

Ask: "Should this color change with the applied theme?"

```typescript
// ✅ Theme-adaptive (changes with theme)
<Button backgroundColor="$color8" theme="danger">Delete</Button>  // Red
<Button backgroundColor="$color8" theme="success">Confirm</Button> // Green

// ✅ Semantic colors (always the same)
<Button backgroundColor="$infoBg" theme="danger">Info</Button>     // Always blue
<Button backgroundColor="$infoBg" theme="success">Info</Button>    // Always blue
```

### Available Themes

- `neutral` (default)
- `highlight`
- `danger`
- `success`
- `warning`
- `info`

## Component Composition

Prefer composing existing components over creating from scratch:

```typescript
import { Card, Button, TitleMedium, BodySmall, XStack, YStack } from '@superapp-caixa/dsc-library';

export const ProductCard = ({ title, description, price, onPress }) => (
  <Card padding="$medium" space="$small">
    <YStack space="$small">
      <TitleMedium numberOfLines={2}>{title}</TitleMedium>
      <BodySmall color="$neutral9">{description}</BodySmall>
      <XStack justifyContent="space-between" alignItems="center">
        <LabelSmall color="$color9">{price}</LabelSmall>
        <Button size="small" onPress={onPress}>Buy</Button>
      </XStack>
    </YStack>
  </Card>
);
```

## TypeScript Patterns

### Interface Definition

```typescript
// .model.ts files
import { ViewProps } from 'react-native';

export interface ComponentProps extends Omit<ViewProps, 'onPress'> {
  /** Visual theme of the component */
  theme?: 'highlight' | 'neutral' | 'danger';
  /** Main content text */
  title: string;
  /** Callback function when pressed */
  onPress?: () => void;
  /** Loading state */
  loading?: boolean;
}
```

## Performance Patterns

### Optimized Components

```typescript
import { memo, useCallback } from 'react';

// Use styled() for reusable components
const OptimizedCard = styled(View, {
  name: 'OptimizedCard',
  backgroundColor: '$color1',
});

// Use memo for complex props
export const ExpensiveComponent = memo(({ data, onPress }) => {
  return <OptimizedCard onPress={onPress} />;
});

// Use useCallback for passed functions
const ParentComponent = () => {
  const handlePress = useCallback((id: string) => {
    // handling logic
  }, []);

  return <OptimizedCard onPress={handlePress} />;
};
```

## Interaction States

### Standard Hook Pattern

```typescript
const useInteractionState = () => {
  const [isFocused, setIsFocused] = useState(false);
  const [isHovered, setIsHovered] = useState(false);
  const [isPressed, setIsPressed] = useState(false);

  const currentState = useMemo(() => {
    if (isPressed) return 'pressed';
    if (isFocused) return 'focused';
    if (isHovered) return 'hovered';
    return 'default';
  }, [isFocused, isHovered, isPressed]);

  const handlers = useMemo(
    () => ({
      onFocus: () => setIsFocused(true),
      onBlur: () => setIsFocused(false),
      onHoverIn: () => setIsHovered(true),
      onHoverOut: () => setIsHovered(false),
      onPressIn: () => setIsPressed(true),
      onPressOut: () => setIsPressed(false),
    }),
    []
  );

  return { currentState, handlers };
};
```

### Z-Index Management

For composite components with focus states:

```typescript
// Use high z-index for focus borders
focusStyle: {
  zIndex: 500,
  position: 'relative',
  borderColor: '$color9',
  borderWidth: 2,
}
```

## Documentation (Portuguese Brazilian)

### Storybook Stories

```typescript
export default {
  title: 'Componentes/Cartões/CartãoDeConta',
  component: CartãoDeConta,
  tags: ['autodocs'],
  parameters: {
    docs: {
      description: {
        component: 'Cartão para exibição de informações de conta bancária.',
      },
    },
  },
  argTypes: {
    theme: {
      description: 'Tema visual do cartão',
      control: { type: 'select' },
      options: ['highlight', 'neutral', 'danger'],
    },
  },
} as Meta<typeof CartãoDeConta>;
```

### JSDoc (Portuguese Brazilian)

````typescript
/**
 * Cartão customizado da DSC Library
 *
 * @param theme - Tema visual aplicado ao cartão
 * @param title - Título principal do cartão
 * @param onPress - Função executada ao pressionar
 *
 * @example
 * ```tsx
 * <CartãoDeConta
 *   theme="highlight"
 *   title="Conta Principal"
 *   onPress={() => console.log('Pressed')}
 * />
 * ```
 */
````

- Default theme is always 'highlight'

### Component Architecture Patterns

- **Modular structure**: Separate Header/Body when component has multiple sections
- **Composition over inheritance**: Use props to compose behavior
- **Hook extraction**: Extract interaction logic to custom hooks
- **Styled components separation**: Keep styled components in separate files
- **Props interface**: Always create proper TypeScript interfaces
- **Default values**: Provide sensible defaults for all optional props

### Storybook Stories (MANDATORY) - EM PORTUGUÊS BRASILEIRO

Criar documentação completa seguindo EXATAMENTE o padrão do IconButton:

**Estrutura obrigatória:**

```typescript
const meta: Meta<ComponentProps> = {
  title: 'Componentes/ComponentName',
  component: Component,
  parameters: {
    layout: 'centered',
    docs: {
      description: {
        component: `
Breve descrição do componente em português.

## Como usar

\`\`\`tsx
import { ComponentName } from '@superapp-caixa/dsc-library';

// Exemplo básico
<ComponentName 
  prop="valor"
  onPress={() => console.log('Pressionado')}
/>

// Exemplo com variações
<ComponentName 
  type="outline"
  size="small"
  onPress={() => console.log('Ação')}
/>
\`\`\`
        `,
      },
      source: {
        transform: (_: string, { args }: any) => {
          // OBRIGATÓRIO: Personalizar o "Show code" para exibir nomes de ícones corretos
          // Em vez de <React.ForwardRef />, mostrar <Home />, <Settings />, etc.

          const props = [
            args.prop1 && `prop1="${args.prop1}"`,
            args.prop2 && `prop2={${args.prop2}}`,
            'onPress={() => {}}',
          ]
            .filter(Boolean)
            .join('\n  ');

          return `<ComponentName
  ${props}
>
  {/* Estrutura específica do componente */}
</ComponentName>`;
        },
        state: 'open',
        excludeDecorators: true,
      },
    },
  },
  tags: ['autodocs'],
  // render e argTypes detalhados...
};
```

**⚠️ IMPORTANTE - source.transform é OBRIGATÓRIO:**

Para corrigir o problema de ícones aparecendo como `<React.ForwardRef />` no "Show code" do Storybook, SEMPRE adicionar a configuração `source.transform` que:

1. **Gera código JSX limpo** com nomes corretos dos ícones
2. **Usa props dinâmicas** baseadas nos controles do Storybook
3. **Exibe estrutura completa** do componente com formatação adequada

**Exemplos de source.transform por tipo de componente:**

```typescript
// Para componentes simples (ex: IconButton)
source: {
  transform: (_: string, { args }: any) => {
    const props = [
      args.type && args.type !== 'plain' && `type="${args.type}"`,
      args.size && args.size !== 'large' && `size="${args.size}"`,
      args.icon && `icon={<${args.icon} />}`,
    ].filter(Boolean).join(' ');

    return `<IconButton${props && ` ${props}`} onPress={() => {}} />`;
  },
}

// Para componentes com children (ex: ButtonRow, ActionsButtonRow)
source: {
  transform: (_: string, { args }: any) => {
    return `<ButtonRow>
  <IconButtonText icon={<Home />}>Início</IconButtonText>
  <IconButtonText icon={<Settings />}>Configurações</IconButtonText>
</ButtonRow>`;
  },
}

// Para componentes complexos (ex: ContentWidgets, WidgetRow)
source: {
  transform: (_: string, { args }: any) => {
    const props = [
      args.title && `title="${args.title}"`,
      args.buttonActionName && `buttonActionName="${args.buttonActionName}"`,
    ].filter(Boolean).join('\n  ');

    return `<ContentWidgets
  ${props}
>
  <WidgetRow>
    <CardWidget icon={<StatsUpSquare />} />
    <CardWidget icon={<CreditCard />} />
  </WidgetRow>
</ContentWidgets>`;
  },
}
```

**Stories obrigatórias:**

- **Default**: Com comentário explicativo em português
- **Variantes**: Para cada tema/tipo
- **Estados**: Loading, disabled, etc.
- **Casos de uso**: Exemplos práticos

**Padrão Default Story:**

```typescript
/**
 * Estado padrão do componente com configurações básicas.
 */
export const Default: Story = {
  args: {
    // Props com valores padrão
  },
};
```

**Outras stories com comentários:**

```typescript
/**
 * Variação do componente com tema danger para estados de erro.
 */
export const Danger: Story = {
  args: {
    theme: 'danger',
    // outras props...
  },
};

/**
 * Exemplo com funcionalidades interativas e callbacks.
 */
export const Interactive: Story = {
  args: {
    onPress: () => alert('Botão pressionado'),
    // outras props...
  },
};
```

**ArgTypes em português:**

- descriptions: "Descrição em português do que a prop faz"
- options: Em português quando aplicável
- table.type.summary: Tipos TypeScript
- table.defaultValue.summary: Valores padrão

### JSDoc Standards - EM PORTUGUÊS BRASILEIRO

Template obrigatório:

````typescript
/**
 * Componente DSC ComponentName
 *
 * Descrição breve em português do propósito e uso do componente.
 *
 * @example
 * ```tsx
 * <ComponentName
 *   prop="valor"
 *   onPress={() => console.log('Pressionado')}
 * />
 * ```
 */
````

**Para props no model:**

```typescript
/**
 * Descrição da prop em português.
 * @default 'valor'
 */
prop?: string;
```

### Required Component Features

Every interactive component must have:

- **Accessibility**: accessibilityLabel, accessibilityRole
- **Theme support**: theme prop with default 'highlight'
- **Interaction states**: focus, hover, press with proper styling
- **TypeScript**: Strict typing with proper interfaces
- **Callback handlers**: onPress, onFocus, onBlur, etc.
- **Touch props**: touchableProps for additional customization

### Focus/Interaction States Pattern

Always implement focus borders like IconButton and Switch:

```typescript
const Wrapper = styled(View, {
  borderRadius: 0,
  padding: borderWidth.thick,
  borderWidth: borderWidth.thick,
  borderColor: 'transparent',

  variants: {
    focused: {
      true: { borderColor: '$neutral12' },
      false: { borderColor: 'transparent' },
    },
  },
});
```

### Layout Specifications

When given layout requirements:

- **Exact spacing**: Use design tokens ($tiny, $nano, $quark, etc.)
- **Exact sizes**: Follow specifications precisely (e.g., 32x32, 16x16)
- **Border radius**: Use tokens ($large, $pill, etc.)
- **Colors**: Always use theme colors ($color1, $color8, etc.)
- **States**: Implement default, hover, pressed, focused states
- **Gap management**: Use gap="$none" when components should touch

### Icon Usage

- Import from 'iconoir-react-native'
- Use useTransformIcon hook for consistent sizing and coloring
- Standard sizes: 12px, 16px, 20px, 24px
- Always use $color1 for icon color in themed components

### Export Pattern

Always export in this order:

```typescript
// Component file
export { Component } from './Component';
export type { ComponentProps } from './Component.model';

// Main index.ts
export { Component } from './components/Component';
export type { ComponentProps } from './components/Component';
```

### Build Verification

After creating/modifying components:

1. Run `npm run build` to verify no errors
2. Check that exports work correctly
3. Verify TypeScript compilation
4. Test Storybook stories

### What NOT to do

- Don't create README.md files for components
- Don't break existing functionality or patterns
- Don't change established conventions without discussion
- Don't add unnecessary dependencies
- Don't create overly complex abstractions
- Don't use hardcoded values instead of design tokens
- Don't skip accessibility features
- Don't ignore interaction states
- Don't forget to export in main index.ts
